<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: virtual-page-manager.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: virtual-page-manager.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * @fileoverview Virtual Page Manager - Efficient address translation and page management
 * @description Handles mapping between virtual buffer addresses and physical page locations
 * while maintaining sparse, efficient access to massive files
 * @author Jeffrey R. Day
 * @version 1.0.0
 */

const fs = require('fs').promises;
const path = require('path');

/**
 * Represents a page's metadata for address translation
 */
class PageDescriptor {
  constructor(pageId, virtualStart, virtualSize, sourceType, sourceInfo) {
    this.pageId = pageId;
    this.virtualStart = virtualStart;    // Where this page starts in the virtual buffer
    this.virtualSize = virtualSize;      // Current size of this page in virtual space
    
    // Source information - where the data actually lives
    this.sourceType = sourceType;        // 'original', 'storage', 'memory'
    this.sourceInfo = sourceInfo;        // Location details
    
    // State tracking
    this.isDirty = false;               // Has been modified
    this.isLoaded = false;              // Currently in memory
    this.lastAccess = 0;                // For LRU eviction
    
    // Split/merge tracking
    this.generation = 0;                // For tracking split history
    this.parentId = null;               // Original page this came from
  }

  /**
   * Get the virtual end position of this page
   */
  get virtualEnd() {
    return this.virtualStart + this.virtualSize;
  }

  /**
   * Check if a virtual position falls within this page
   */
  contains(virtualPos) {
    return virtualPos >= this.virtualStart &amp;&amp; virtualPos &lt; this.virtualEnd;
  }

  /**
   * Convert virtual position to relative position within this page
   */
  toRelativePosition(virtualPos) {
    if (!this.contains(virtualPos)) {
      throw new Error(`Position ${virtualPos} not in page ${this.pageId}`);
    }
    return virtualPos - this.virtualStart;
  }
}

/**
 * Efficient B-tree-like structure for fast address lookups
 * Uses binary search for O(log n) lookups even with thousands of pages
 */
class PageAddressIndex {
  constructor() {
    this.pages = [];           // Sorted array of PageDescriptors by virtualStart
    this.totalVirtualSize = 0; // Cache of total virtual buffer size
  }

  /**
   * Find the page containing a virtual address
   * @param {number} virtualPos - Virtual position to look up
   * @returns {PageDescriptor|null} - Page containing this position
   */
  findPageAt(virtualPos) {
    if (this.pages.length === 0) return null;
    
    // Binary search for the correct page
    let left = 0;
    let right = this.pages.length - 1;
    
    while (left &lt;= right) {
      const mid = Math.floor((left + right) / 2);
      const page = this.pages[mid];
      
      if (page.contains(virtualPos)) {
        return page;
      } else if (virtualPos &lt; page.virtualStart) {
        right = mid - 1;
      } else {
        left = mid + 1;
      }
    }
    
    return null;
  }

  /**
   * Insert a new page, maintaining sorted order
   * @param {PageDescriptor} pageDesc - Page to insert
   */
  insertPage(pageDesc) {
    // Find insertion point using binary search
    let insertIndex = 0;
    for (let i = 0; i &lt; this.pages.length; i++) {
      if (this.pages[i].virtualStart > pageDesc.virtualStart) {
        insertIndex = i;
        break;
      }
      insertIndex = i + 1;
    }
    
    this.pages.splice(insertIndex, 0, pageDesc);
    this._updateVirtualSizes();
  }

  /**
   * Remove a page from the index
   * @param {string} pageId - ID of page to remove
   */
  removePage(pageId) {
    const index = this.pages.findIndex(p => p.pageId === pageId);
    if (index >= 0) {
      this.pages.splice(index, 1);
      this._updateVirtualSizes();
    }
  }

  /**
   * Update virtual addresses after a size change
   * @param {string} pageId - Page that changed size
   * @param {number} sizeDelta - Change in size (positive or negative)
   */
  updatePageSize(pageId, sizeDelta) {
    const pageIndex = this.pages.findIndex(p => p.pageId === pageId);
    if (pageIndex &lt; 0) return;
    
    const page = this.pages[pageIndex];
    page.virtualSize += sizeDelta;
    
    // Shift all subsequent pages
    for (let i = pageIndex + 1; i &lt; this.pages.length; i++) {
      this.pages[i].virtualStart += sizeDelta;
    }
    
    this.totalVirtualSize += sizeDelta;
  }

  /**
   * Split a page into two pages
   * @param {string} pageId - Page to split
   * @param {number} splitPoint - Relative position within page to split at
   * @param {string} newPageId - ID for the new second page
   * @returns {PageDescriptor} - The new second page descriptor
   */
  splitPage(pageId, splitPoint, newPageId) {
    const pageIndex = this.pages.findIndex(p => p.pageId === pageId);
    if (pageIndex &lt; 0) throw new Error(`Page ${pageId} not found`);
    
    const originalPage = this.pages[pageIndex];
    const splitVirtualPos = originalPage.virtualStart + splitPoint;
    
    // Create new page for the second half
    const newPage = new PageDescriptor(
      newPageId,
      splitVirtualPos,
      originalPage.virtualSize - splitPoint,
      'memory', // Split pages start in memory
      { pageId: newPageId }
    );
    newPage.isDirty = true;
    newPage.generation = originalPage.generation + 1;
    newPage.parentId = originalPage.pageId;
    
    // Update original page to first half
    originalPage.virtualSize = splitPoint;
    
    // Insert new page right after original
    this.pages.splice(pageIndex + 1, 0, newPage);
    
    return newPage;
  }

  /**
   * Get all pages in virtual address order
   */
  getAllPages() {
    return [...this.pages];
  }

  /**
   * Get pages that intersect with a virtual range
   * @param {number} startPos - Start of range
   * @param {number} endPos - End of range
   * @returns {PageDescriptor[]} - Pages that intersect the range
   */
  getPagesInRange(startPos, endPos) {
    const result = [];
    
    for (const page of this.pages) {
      if (page.virtualStart >= endPos) break;
      if (page.virtualEnd > startPos) {
        result.push(page);
      }
    }
    
    return result;
  }

  /**
   * Recalculate total virtual size
   * @private
   */
  _updateVirtualSizes() {
    this.totalVirtualSize = this.pages.reduce((sum, page) => sum + page.virtualSize, 0);
  }

  /**
   * Validate the index consistency (for debugging)
   */
  validate() {
    let expectedStart = 0;
    
    for (let i = 0; i &lt; this.pages.length; i++) {
      const page = this.pages[i];
      
      if (page.virtualStart !== expectedStart) {
        throw new Error(`Page ${page.pageId} has invalid virtual start: expected ${expectedStart}, got ${page.virtualStart}`);
      }
      
      if (page.virtualSize &lt;= 0) {
        throw new Error(`Page ${page.pageId} has invalid size: ${page.virtualSize}`);
      }
      
      expectedStart += page.virtualSize;
    }
    
    if (expectedStart !== this.totalVirtualSize) {
      throw new Error(`Total size mismatch: expected ${expectedStart}, got ${this.totalVirtualSize}`);
    }
  }
}

/**
 * Virtual Page Manager - The core address translation system
 */
class VirtualPageManager {
  constructor(buffer, pageSize = 64 * 1024) {
    this.buffer = buffer;
    this.pageSize = pageSize;
    this.nextPageId = 0;
    
    // Core data structures
    this.addressIndex = new PageAddressIndex();
    this.pageCache = new Map();        // pageId -> actual PageInfo objects
    this.loadedPages = new Set();      // Track which pages are in memory
    
    // Source file information
    this.sourceFile = null;
    this.sourceSize = 0;
    this.sourceChecksum = null;
    
    // Memory management
    this.maxLoadedPages = 100;
    this.lruOrder = [];               // For eviction decisions
  }

  /**
   * Initialize from a file
   * @param {string} filename - Source file path
   * @param {number} fileSize - File size
   * @param {string} checksum - File checksum
   */
  initializeFromFile(filename, fileSize, checksum) {
    this.sourceFile = filename;
    this.sourceSize = fileSize;
    this.sourceChecksum = checksum;
    
    // Create initial page descriptors for the entire file
    this._createInitialPages(fileSize);
  }

  /**
   * Initialize from string content
   * @param {Buffer} content - Content buffer
   */
  initializeFromContent(content) {
    this.sourceFile = null;
    this.sourceSize = content.length;
    
    // Handle empty content
    if (content.length === 0) {
      const pageId = this._generatePageId();
      const pageDesc = new PageDescriptor(
        pageId,
        0,              // virtualStart
        0,              // virtualSize
        'memory',       // sourceType
        { pageId }      // sourceInfo
      );
      pageDesc.isDirty = true;
      pageDesc.isLoaded = true;
      
      this.addressIndex.insertPage(pageDesc);
      this.pageCache.set(pageId, this._createPageInfo(pageDesc, Buffer.alloc(0)));
      this.loadedPages.add(pageId);
      
      // Apply memory limit after initialization
      this._applyMemoryLimit();
      return;
    }
    
    // Create pages for content, respecting page size limits
    let offset = 0;
    while (offset &lt; content.length) {
      const pageSize = Math.min(this.pageSize, content.length - offset);
      const pageId = this._generatePageId();
      const pageData = content.subarray(offset, offset + pageSize);
      
      const pageDesc = new PageDescriptor(
        pageId,
        offset,         // virtualStart
        pageSize,       // virtualSize
        'memory',       // sourceType
        { pageId }      // sourceInfo
      );
      pageDesc.isDirty = true;
      pageDesc.isLoaded = true;
      
      this.addressIndex.insertPage(pageDesc);
      this.pageCache.set(pageId, this._createPageInfo(pageDesc, pageData));
      this.loadedPages.add(pageId);
      
      offset += pageSize;
    }
    
    // Apply memory limit after initialization
    this._applyMemoryLimit();
  }

  /**
   * Apply memory limit by evicting excess pages
   * @private
   */
  async _applyMemoryLimit() {
    while (this.loadedPages.size > this.maxLoadedPages) {
      // Find the oldest loaded page to evict
      const pageIds = Array.from(this.loadedPages);
      if (pageIds.length === 0) break;
      
      const pageToEvict = pageIds[0]; // Evict first (oldest) page
      const descriptor = this.addressIndex.pages.find(p => p.pageId === pageToEvict);
      
      if (descriptor &amp;&amp; descriptor.isLoaded) {
        await this._evictPage(descriptor);
      }
    }
  }

  /**
   * Translate virtual address to page and relative position
   * @param {number} virtualPos - Virtual buffer position
   * @returns {Promise&lt;{page: PageInfo, relativePos: number, descriptor: PageDescriptor}>}
   */
  async translateAddress(virtualPos) {
    // Handle negative positions
    if (virtualPos &lt; 0) {
      throw new Error(`No page found for virtual position ${virtualPos}`);
    }
    
    // Allow insertion at the very end of the buffer
    if (virtualPos === this.addressIndex.totalVirtualSize) {
      // Find the last page or create one if empty
      const allPages = this.addressIndex.getAllPages();
      if (allPages.length === 0) {
        // Create an empty page for insertion
        const pageId = this._generatePageId();
        const pageDesc = new PageDescriptor(pageId, 0, 0, 'memory', { pageId });
        pageDesc.isDirty = true;
        pageDesc.isLoaded = true;
        
        this.addressIndex.insertPage(pageDesc);
        this.pageCache.set(pageId, this._createPageInfo(pageDesc, Buffer.alloc(0)));
        this.loadedPages.add(pageId);
        
        return {
          page: this.pageCache.get(pageId),
          relativePos: 0,
          descriptor: pageDesc
        };
      } else {
        const lastPage = allPages[allPages.length - 1];
        const pageInfo = await this._ensurePageLoaded(lastPage);
        return {
          page: pageInfo,
          relativePos: lastPage.virtualSize,
          descriptor: lastPage
        };
      }
    }
    
    // For positions beyond the end of buffer, throw error
    if (virtualPos > this.addressIndex.totalVirtualSize) {
      throw new Error(`No page found for virtual position ${virtualPos}`);
    }
    
    const descriptor = this.addressIndex.findPageAt(virtualPos);
    if (!descriptor) {
      throw new Error(`No page found for virtual position ${virtualPos}`);
    }
    
    const relativePos = descriptor.toRelativePosition(virtualPos);
    const pageInfo = await this._ensurePageLoaded(descriptor);
    
    return {
      page: pageInfo,
      relativePos,
      descriptor
    };
  }

  /**
   * Insert data at a virtual position
   * @param {number} virtualPos - Position to insert at
   * @param {Buffer} data - Data to insert
   */
  async insertAt(virtualPos, data) {
    const { descriptor, relativePos } = await this.translateAddress(virtualPos);
    const pageInfo = await this._ensurePageLoaded(descriptor);
    
    // Perform the insertion within the page
    const before = pageInfo.data.subarray(0, relativePos);
    const after = pageInfo.data.subarray(relativePos);
    const newData = Buffer.concat([before, data, after]);
    
    // Update page data
    pageInfo.updateData(newData, this.buffer.mode);
    descriptor.isDirty = true;
    
    // Update virtual addresses
    this.addressIndex.updatePageSize(descriptor.pageId, data.length);
    
    // Check if page needs splitting
    if (newData.length > this.pageSize * 2) {
      await this._splitPage(descriptor);
    }
    
    return data.length;
  }

  /**
   * Delete data from a virtual range
   * @param {number} startPos - Start position
   * @param {number} endPos - End position
   * @returns {Promise&lt;Buffer>} - Deleted data
   */
  async deleteRange(startPos, endPos) {
    if (startPos >= endPos) {
      return Buffer.alloc(0);
    }
    
    // Clamp to valid range
    startPos = Math.max(0, startPos);
    endPos = Math.min(endPos, this.addressIndex.totalVirtualSize);
    
    if (startPos >= endPos) {
      return Buffer.alloc(0);
    }
    
    const deletedChunks = [];
    const affectedPages = this.addressIndex.getPagesInRange(startPos, endPos);
    
    // Process pages in reverse order to maintain position consistency
    for (let i = affectedPages.length - 1; i >= 0; i--) {
      const descriptor = affectedPages[i];
      const pageInfo = await this._ensurePageLoaded(descriptor);
      
      // Calculate intersection with delete range
      const deleteStart = Math.max(startPos, descriptor.virtualStart);
      const deleteEnd = Math.min(endPos, descriptor.virtualEnd);
      
      const relativeStart = deleteStart - descriptor.virtualStart;
      const relativeEnd = deleteEnd - descriptor.virtualStart;
      
      // Extract deleted data
      const deletedFromPage = pageInfo.data.subarray(relativeStart, relativeEnd);
      
      // Insert at beginning of array to maintain order
      deletedChunks.unshift(deletedFromPage);
      
      // Remove data from page
      const before = pageInfo.data.subarray(0, relativeStart);
      const after = pageInfo.data.subarray(relativeEnd);
      const newData = Buffer.concat([before, after]);
      
      pageInfo.updateData(newData, this.buffer.mode);
      descriptor.isDirty = true;
      
      // Update virtual size
      const sizeChange = -(relativeEnd - relativeStart);
      this.addressIndex.updatePageSize(descriptor.pageId, sizeChange);
    }
    
    // Clean up empty pages
    await this._cleanupEmptyPages();
    
    return Buffer.concat(deletedChunks);
  }

  /**
   * Read data from a virtual range
   * @param {number} startPos - Start position
   * @param {number} endPos - End position
   * @returns {Promise&lt;Buffer>} - Read data
   */
  async readRange(startPos, endPos) {
    if (startPos >= endPos) {
      return Buffer.alloc(0);
    }
    
    // Clamp to valid range
    startPos = Math.max(0, startPos);
    endPos = Math.min(endPos, this.addressIndex.totalVirtualSize);
    
    if (startPos >= endPos) {
      return Buffer.alloc(0);
    }
    
    const chunks = [];
    const affectedPages = this.addressIndex.getPagesInRange(startPos, endPos);
    
    for (const descriptor of affectedPages) {
      try {
        const pageInfo = await this._ensurePageLoaded(descriptor);
        
        // Calculate intersection with read range
        const readStart = Math.max(startPos, descriptor.virtualStart);
        const readEnd = Math.min(endPos, descriptor.virtualEnd);
        
        const relativeStart = readStart - descriptor.virtualStart;
        const relativeEnd = readEnd - descriptor.virtualStart;
        
        // Handle case where page data is shorter than expected
        const actualEnd = Math.min(relativeEnd, pageInfo.data.length);
        
        if (relativeStart &lt; pageInfo.data.length) {
          chunks.push(pageInfo.data.subarray(relativeStart, actualEnd));
        }
        
        // If we couldn't read the full expected range, fill with zeros or handle missing data
        if (actualEnd &lt; relativeEnd) {
          const missingBytes = relativeEnd - actualEnd;
          // Fill missing with zeros for now - detachment is already handled in _ensurePageLoaded
          chunks.push(Buffer.alloc(missingBytes));
        }
        
      } catch (error) {
        // Page loading failed - this range will be missing from output
        // The _ensurePageLoaded method already handled detachment notification
        const missingSize = Math.min(endPos, descriptor.virtualEnd) - 
                           Math.max(startPos, descriptor.virtualStart);
        chunks.push(Buffer.alloc(missingSize)); // Fill with zeros
      }
    }
    
    return Buffer.concat(chunks);
  }

  /**
   * Get total virtual size
   */
  getTotalSize() {
    return this.addressIndex.totalVirtualSize;
  }

  /**
   * Get memory statistics
   */
  getMemoryStats() {
    const totalPages = this.addressIndex.pages.length;
    const loadedPages = this.loadedPages.size;
    const dirtyPages = this.addressIndex.pages.filter(p => p.isDirty).length;
    
    let memoryUsed = 0;
    for (const pageId of this.loadedPages) {
      const pageInfo = this.pageCache.get(pageId);
      if (pageInfo &amp;&amp; pageInfo.data) {
        memoryUsed += pageInfo.data.length;
      }
    }
    
    return {
      totalPages,
      loadedPages,
      dirtyPages,
      memoryUsed,
      virtualSize: this.addressIndex.totalVirtualSize,
      sourceSize: this.sourceSize
    };
  }

  // =================== PRIVATE METHODS ===================

  /**
   * Create initial page descriptors for a file
   * @private
   */
  _createInitialPages(fileSize) {
    let offset = 0;
    
    // Handle empty files
    if (fileSize === 0) {
      const pageId = this._generatePageId();
      const descriptor = new PageDescriptor(
        pageId,
        0,              // virtualStart
        0,              // virtualSize - empty page
        'original',     // sourceType
        {               // sourceInfo
          filename: this.sourceFile,
          fileOffset: 0,
          size: 0
        }
      );
      
      this.addressIndex.insertPage(descriptor);
      return;
    }
    
    while (offset &lt; fileSize) {
      const pageSize = Math.min(this.pageSize, fileSize - offset);
      const pageId = this._generatePageId();
      
      const descriptor = new PageDescriptor(
        pageId,
        offset,         // virtualStart
        pageSize,       // virtualSize
        'original',     // sourceType
        {               // sourceInfo
          filename: this.sourceFile,
          fileOffset: offset,
          size: pageSize
        }
      );
      
      this.addressIndex.insertPage(descriptor);
      offset += pageSize;
    }
  }

  /**
   * Enhanced page loading with detachment detection
   * @private
   */
  async _ensurePageLoaded(descriptor) {
    if (descriptor.isLoaded &amp;&amp; this.pageCache.has(descriptor.pageId)) {
      this._updateLRU(descriptor.pageId);
      return this.pageCache.get(descriptor.pageId);
    }
    
    // Load page data based on source type
    let data;
    let loadError = null;
    
    try {
      switch (descriptor.sourceType) {
        case 'original':
          data = await this._loadFromOriginalFile(descriptor);
          break;
        case 'storage':
          data = await this._loadFromStorage(descriptor);
          break;
        case 'memory':
          // Handle memory pages that might have been evicted
          if (this.pageCache.has(descriptor.pageId)) {
            const pageInfo = this.pageCache.get(descriptor.pageId);
            this._updateLRU(descriptor.pageId);
            descriptor.isLoaded = true;
            return pageInfo;
          }
          // Try to load from storage first
          try {
            data = await this._loadFromStorage(descriptor);
            descriptor.sourceType = 'storage';
          } catch (storageError) {
            // Memory page unavailable and not in storage
            loadError = new Error(`Memory page ${descriptor.pageId} unavailable: ${storageError.message}`);
            throw loadError;
          }
          break;
        default:
          loadError = new Error(`Unknown source type: ${descriptor.sourceType}`);
          throw loadError;
      }
    } catch (error) {
      // CRITICAL: Data unavailable - trigger detachment
      loadError = error;
      this._handleCorruption(descriptor, error);
      
      // Return empty page info to allow operations to continue
      data = Buffer.alloc(0);
    }
    
    const pageInfo = this._createPageInfo(descriptor, data);
    this.pageCache.set(descriptor.pageId, pageInfo);
    this.loadedPages.add(descriptor.pageId);
    descriptor.isLoaded = true;
    
    // Update LRU and possibly evict
    this._updateLRU(descriptor.pageId);
    await this._evictIfNeeded();
    
    return pageInfo;
  }

  /**
   * Enhanced corruption handling that properly triggers detachment
   */
  _handleCorruption(descriptor, error) {
    // Import MissingDataRange from the main module
    const { MissingDataRange } = require('./paged-buffer');
    
    const missingRange = new MissingDataRange(
      descriptor.virtualStart,
      descriptor.virtualEnd,
      descriptor.sourceType === 'original' ? descriptor.sourceInfo.fileOffset : null,
      descriptor.sourceType === 'original' ? 
        descriptor.sourceInfo.fileOffset + descriptor.sourceInfo.size : null,
      this._determineCorruptionReason(error)
    );
    
    // CRITICAL: Trigger buffer detachment
    if (this.buffer._markAsDetached) {
      this.buffer._markAsDetached(`Page data unavailable: ${error.message}`, [missingRange]);
    }
    
    // Send detailed notification
    this.buffer._notify(
      'page_data_unavailable',
      'error',
      `Page ${descriptor.pageId} data unavailable: ${error.message}`,
      { 
        pageId: descriptor.pageId,
        virtualStart: descriptor.virtualStart,
        virtualEnd: descriptor.virtualEnd,
        sourceType: descriptor.sourceType,
        reason: error.message,
        recoverable: false
      }
    );
  }
  
  /**
   * Determine the specific reason for corruption based on error
   */
  _determineCorruptionReason(error) {
    if (error.message.includes('ENOENT')) {
      return 'file_deleted';
    } else if (error.message.includes('truncated') || error.message.includes('beyond current size')) {
      return 'file_truncated';
    } else if (error.message.includes('Permission denied') || error.message.includes('EACCES')) {
      return 'permission_denied';
    } else if (error.message.includes('Storage')) {
      return 'storage_failure';
    } else {
      return 'data_corruption';
    }
  }
  
  


  /**  Maybe UNUSED
   * Handle missing data by notifying the buffer
   * @private
   */
  _handleMissingData(descriptor, reason) {
    // Import MissingDataRange from the main module
    const { MissingDataRange } = require('./paged-buffer');
    
    const missingRange = new MissingDataRange(
      descriptor.virtualStart,
      descriptor.virtualEnd,
      descriptor.sourceType === 'original' ? descriptor.sourceInfo.fileOffset : null,
      descriptor.sourceType === 'original' ? 
        descriptor.sourceInfo.fileOffset + descriptor.sourceInfo.size : null,
      reason
    );
    
    // Notify buffer of data loss
    if (this.buffer._markAsDetached) {
      this.buffer._markAsDetached(`Page data unavailable: ${reason}`, [missingRange]);
    }
    
    this.buffer._notify(
      'page_data_unavailable',
      'error',
      `Page ${descriptor.pageId} data unavailable: ${reason}`,
      { 
        pageId: descriptor.pageId,
        virtualStart: descriptor.virtualStart,
        virtualEnd: descriptor.virtualEnd,
        reason 
      }
    );
  }

  /**
   * Enhanced file loading with better corruption detection
   */
  async _loadFromOriginalFile(descriptor) {
    if (!descriptor.sourceInfo.filename) {
      throw new Error('No source filename available');
    }
    
    const fs = require('fs').promises;
    
    try {
      // First check if file exists and is readable
      await fs.access(descriptor.sourceInfo.filename, require('fs').constants.R_OK);
      
      // Get current file stats
      const stats = await fs.stat(descriptor.sourceInfo.filename);
      
      // CRITICAL: Check if file has been truncated since we loaded it
      if (descriptor.sourceInfo.fileOffset >= stats.size) {
        throw new Error(`File truncated: offset ${descriptor.sourceInfo.fileOffset} beyond current size ${stats.size}`);
      }
      
      // Calculate how much we can actually read
      const maxReadSize = stats.size - descriptor.sourceInfo.fileOffset;
      const readSize = Math.min(descriptor.sourceInfo.size, maxReadSize);
      
      if (readSize &lt;= 0) {
        throw new Error(`No data available at offset ${descriptor.sourceInfo.fileOffset}`);
      }
      
      // Open and read the file
      const fd = await fs.open(descriptor.sourceInfo.filename, 'r');
      
      try {
        const buffer = Buffer.alloc(readSize);
        const { bytesRead } = await fd.read(
          buffer, 
          0, 
          readSize, 
          descriptor.sourceInfo.fileOffset
        );
        
        if (bytesRead === 0) {
          throw new Error(`No data read from offset ${descriptor.sourceInfo.fileOffset}`);
        }
        
        if (bytesRead !== readSize) {
          // Partial read - file changed during read
          console.warn(`Partial read: expected ${readSize}, got ${bytesRead}`);
          return buffer.subarray(0, bytesRead);
        }
        
        return buffer;
      } finally {
        await fd.close();
      }
      
    } catch (error) {
      // Enhanced error context
      const enhancedError = new Error(`Failed to load from ${descriptor.sourceInfo.filename}: ${error.message}`);
      enhancedError.originalError = error;
      enhancedError.sourceInfo = descriptor.sourceInfo;
      throw enhancedError;
    }
  }

  /**
   * Enhanced storage loading with better error handling
   */
  async _loadFromStorage(descriptor) {
    try {
      const data = await this.buffer.storage.loadPage(descriptor.pageId);
      if (!data || data.length === 0) {
        throw new Error(`Storage returned empty data for page ${descriptor.pageId}`);
      }
      return data;
    } catch (error) {
      // Enhanced storage error
      const enhancedError = new Error(`Storage load failed for page ${descriptor.pageId}: ${error.message}`);
      enhancedError.originalError = error;
      enhancedError.pageId = descriptor.pageId;
      throw enhancedError;
    }
  }

  /**
   * Fix _createPageInfo to handle missing PageInfo import
   */
  _createPageInfo(descriptor, data) {
    // Try to import PageInfo, fallback to mock if not available
    let PageInfo;
    try {
      PageInfo = require('./utils/page-info').PageInfo;
    } catch (error) {
      // Create minimal PageInfo mock for testing
      PageInfo = class {
        constructor(pageId, fileOffset, originalSize) {
          this.pageId = pageId;
          this.fileOffset = fileOffset;
          this.originalSize = originalSize;
          this.currentSize = originalSize;
          this.data = null;
          this.isDirty = false;
          this.isLoaded = false;
        }
        
        updateData(data, mode) {
          this.data = data;
          this.currentSize = data.length;
          this.isDirty = true;
          this.isLoaded = true;
        }
      };
    }
    
    const pageInfo = new PageInfo(
      descriptor.pageId,
      descriptor.sourceType === 'original' ? descriptor.sourceInfo.fileOffset : -1,
      descriptor.sourceType === 'original' ? descriptor.sourceInfo.size : 0
    );
    pageInfo.updateData(data, this.buffer.mode);
    pageInfo.isDirty = descriptor.isDirty;
    pageInfo.isLoaded = true;
    return pageInfo;
  }

  /**
   * Split a page that has grown too large
   * @private
   */
  async _splitPage(descriptor) {
    const pageInfo = this.pageCache.get(descriptor.pageId);
    if (!pageInfo) return;
    
    const splitPoint = Math.floor(pageInfo.currentSize / 2);
    const newPageId = this._generatePageId();
    
    // Split the page in the address index
    const newDescriptor = this.addressIndex.splitPage(
      descriptor.pageId,
      splitPoint,
      newPageId
    );
    
    // Create new page data
    const newData = pageInfo.data.subarray(splitPoint);
    const newPageInfo = this._createPageInfo(newDescriptor, newData);
    
    // Update original page data
    const originalData = pageInfo.data.subarray(0, splitPoint);
    pageInfo.updateData(originalData, this.buffer.mode);
    
    // Cache the new page
    this.pageCache.set(newPageId, newPageInfo);
    this.loadedPages.add(newPageId);
    
    this._updateLRU(newPageId);
    
    this.buffer._notify(
      'page_split',
      'info',
      `Split page ${descriptor.pageId} at ${splitPoint} bytes`,
      { originalPageId: descriptor.pageId, newPageId, splitPoint }
    );
  }

  /**
   * Clean up pages that have become empty
   * @private
   */
  async _cleanupEmptyPages() {
    const emptyPages = this.addressIndex.pages.filter(p => p.virtualSize === 0);
    
    for (const descriptor of emptyPages) {
      this.addressIndex.removePage(descriptor.pageId);
      this.pageCache.delete(descriptor.pageId);
      this.loadedPages.delete(descriptor.pageId);
      
      // Remove from storage if it was saved there
      if (descriptor.sourceType === 'storage') {
        try {
          await this.buffer.storage.deletePage(descriptor.pageId);
        } catch (error) {
          // Ignore deletion errors
        }
      }
    }
  }

  /**
   * Update LRU order
   * @private
   */
  _updateLRU(pageId) {
    const index = this.lruOrder.indexOf(pageId);
    if (index >= 0) {
      this.lruOrder.splice(index, 1);
    }
    this.lruOrder.push(pageId);
  }

  /**
   * Evict pages if over memory limit
   * @private
   */
  async _evictIfNeeded() {
    while (this.loadedPages.size > this.maxLoadedPages &amp;&amp; this.lruOrder.length > 0) {
      const pageId = this.lruOrder.shift();
      const descriptor = this.addressIndex.pages.find(p => p.pageId === pageId);
      
      if (descriptor &amp;&amp; descriptor.isLoaded &amp;&amp; this.loadedPages.has(pageId)) {
        await this._evictPage(descriptor);
      }
    }
  }

  /**
   * Evict a specific page
   * @private
   */
  async _evictPage(descriptor) {
    const pageInfo = this.pageCache.get(descriptor.pageId);
    if (!pageInfo) return;
    
    // Save to storage if dirty
    if (descriptor.isDirty) {
      try {
        await this.buffer.storage.savePage(descriptor.pageId, pageInfo.data);
        descriptor.sourceType = 'storage';
        descriptor.sourceInfo = { pageId: descriptor.pageId };
      } catch (error) {
        // If storage fails, we can't evict this page safely
        // Log the error and continue without evicting
        this.buffer._notify(
          'storage_error',
          'error',
          `Failed to save page ${descriptor.pageId} during eviction: ${error.message}`,
          { pageId: descriptor.pageId, error: error.message }
        );
        return false; // Indicate eviction failed
      }
    }
    
    // Remove from memory
    this.pageCache.delete(descriptor.pageId);
    this.loadedPages.delete(descriptor.pageId);
    descriptor.isLoaded = false;
    
    this.buffer._notify(
      'page_evicted',
      'debug',
      `Evicted page ${descriptor.pageId}`,
      { pageId: descriptor.pageId }
    );
    
    return true; // Indicate eviction succeeded
  }

  /**
   * Generate unique page ID
   * @private
   */
  _generatePageId() {
    return `vpage_${++this.nextPageId}_${Date.now()}`;
  }
}

module.exports = {
  VirtualPageManager,
  PageDescriptor,
  PageAddressIndex
};
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="BufferNotification.html">BufferNotification</a></li><li><a href="BufferOperation.html">BufferOperation</a></li><li><a href="BufferUndoSystem.html">BufferUndoSystem</a></li><li><a href="FilePageStorage.html">FilePageStorage</a></li><li><a href="MemoryPageStorage.html">MemoryPageStorage</a></li><li><a href="MissingDataRange.html">MissingDataRange</a></li><li><a href="ModificationAnalyzer.html">ModificationAnalyzer</a></li><li><a href="OperationDescriptor.html">OperationDescriptor</a></li><li><a href="OperationDistanceCalculator.html">OperationDistanceCalculator</a></li><li><a href="OperationGroup.html">OperationGroup</a></li><li><a href="OperationPosition.html">OperationPosition</a></li><li><a href="OperationTransaction.html">OperationTransaction</a></li><li><a href="PageAddressIndex.html">PageAddressIndex</a></li><li><a href="PageDescriptor.html">PageDescriptor</a></li><li><a href="PageInfo.html">PageInfo</a></li><li><a href="PageStorage.html">PageStorage</a></li><li><a href="PagedBuffer.html">PagedBuffer</a></li><li><a href="SafeFileWriter.html">SafeFileWriter</a></li><li><a href="SmartStrategySelector.html">SmartStrategySelector</a></li><li><a href="VirtualPageManager.html">VirtualPageManager</a></li></ul><h3>Global</h3><ul><li><a href="global.html#BufferMode">BufferMode</a></li><li><a href="global.html#BufferState">BufferState</a></li><li><a href="global.html#FileChangeStrategy">FileChangeStrategy</a></li><li><a href="global.html#NotificationType">NotificationType</a></li><li><a href="global.html#OperationType">OperationType</a></li><li><a href="global.html#RiskLevel">RiskLevel</a></li><li><a href="global.html#SaveStrategy">SaveStrategy</a></li><li><a href="global.html#crypto">crypto</a></li><li><a href="global.html#fs">fs</a></li><li><a href="global.html#getOperationCounter">getOperationCounter</a></li><li><a href="global.html#globalOperationCounter">globalOperationCounter</a></li><li><a href="global.html#resetOperationCounter">resetOperationCounter</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.4</a> on Sat May 31 2025 16:44:22 GMT-0700 (Pacific Daylight Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
